---
sidebar_position: 6
---

# Microservices Design

After identifying the application requirements and the main components of the architecture, we can now define the microservices design of the system.

Each service will be responsible for a specific set of features and will communicate with other services through well-defined APIs. This will allow us to develop and deploy each service independently, making it easier to scale the system and add new features in the future.

The decomposition of the system allows us to use different technologies for each service, as well as to scale each service independently based on its specific requirements.

## API Design

Each microservice will either expose a REST API or a WebSocket API for communication with other services. The API will be designed to be simple, consistent, and easy to use. We will follow RESTful design principles for the REST APIs and use WebSockets for real-time communication between services.

The API will be versioned to ensure backward compatibility and allow for future changes without breaking existing clients.

The API will be documented using OpenAPI (formerly known as Swagger) to provide a clear and comprehensive reference for developers who want to integrate with the system.

### Auth Service

The Auth service will expose a REST API for user authentication and authorization. It will provide endpoints for user registration, login, and logout.

<Summary title="Feature: Authentication">

```gherkin
Feature: Authentication
  As a user
  I want to be able to authenticate with the system
  So that I can access my account

Scenario: User registration
Given I want to register
When I provide a valid registration data
Then I should be registered successfully

Scenario: User login
Given I am a registered user
When I provide a valid login credentials
Then I should be logged in successfully

Scenario: User logout
Given I am a logged-in user
When I log out
Then I should be logged out successfully

```

</Summary>

[OpenAPI Specification](/api/auth)

### Profile Service

The Profile service will expose a REST API for managing user profiles. It will provide endpoints for viewing and editing user profiles.

<Summary title="Feature: Profile">

```gherkin
Feature: Profile
  As a user
  I want to be able to view and edit my profile
  So that I can update my information

Scenario: View profile
Given I am a logged-in user
When I request to view a user profile
Then The user profile should be returned

Scenario: Edit profile
Given I am a logged-in user
When I update my profile information
Then My user profile should be updated

```

</Summary>

[OpenAPI Specification](/api/profile)

### Session Service

The Session service will expose a WebSocket API for managing sessions. It will provide endpoints for creating, joining, and leaving sessions. It will also handle video playback synchronization and chat functionality.

<Summary title="Feature: Session">

```gherkin
Feature: Session
  As a user
  I want to be able to create and join a streaming session
  So that I can interact with the Youtube video and the chat

Scenario: Create a Session
Given I am a user logged-in
When I create a streaming Session by providing a correct Youtube URL
Then I should receive the Session name

Scenario: Join a Session
Given I am a user logged-in
When I join a streaming Session by providing a correct Session name
Then I should receive the Youtube video Id

Scenario: Leave a Session
Given I am logged-in user and I am joined in a Session
When I leave the Session
Then I should be successfully disconnected from the Session 

Scenario: Play/stop/move the timeline of a Session Video
Given I am logged-in user and I am joined in a Session
When I play/stop/move the timeline of the Session Video
Then I should receive a Video State as a synchronization message

Scenario: Join a Session
Given I am a user logged-in
When I join a streaming Session by providing a correct Session name
Then I should receive the Youtube video Id

```

</Summary>

[AsyncAPI Specification](https://letsstreamit.github.io/session-service/api/)

## Clean Architecture


![Clean Architecture](/img/ddd/detailed_design/clean_architecture.png)

The design of all the microservices follow the [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html).
This architecture allows to separate the domain from the implementation details. The architecture is composed of multiple layers and is based on the *Dependency Rule*,
i.e. each layer can only depend on the inner layers. The adopted layers are the following:
- Domain. It's the innermost layer and should contain the business logic of the microservice. It comprises DDD aggregates, value objects, entities, factories and repositories;
- Application. Should contain services;
- Presentation. Should handle data serialization/deserialization for sending/receiving data with other microservices;
- Infrastructure. Should manage the communication with the external microservices.
