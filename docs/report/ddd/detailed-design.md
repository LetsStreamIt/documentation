---
sidebar_position: 6
---


import Packages from '/img/ddd/detailed_design/session/packages.png';
import ServiceApp from '/img/ddd/detailed_design/session/session-service-application.png';
import Aggregates from '/img/ddd/detailed_design/session/session-appl-aggregate.png';


import AuthPackages from '/img/ddd/detailed_design/auth/packages.png';


# Detailed Design


## Session Microservice


The Session microservice is responsible for managing Youtube streaming sessions. The application synchronizes the video of all the users connected to a session, in response to play/stop/timeline moves actions.


It also maintains up-to-date Session chat, through which users can communicate with each other during the streaming.


### Project structure


<img src={Packages} alt="packages" style={{ height: 500, display: 'block', margin: 'auto' }} />


The Session microservice follows the Clean architecture pattern to maintain separate code responsibilities and enhance software modularity. The business logic is placed in the domain layer, inside the aggregates previously identified, while the communication is captured by the infrastructure layer.


The application layer acts as a middleware between the infrastructure and domain layer.


### Design


The software moves around the concepts of **Commands**, **Domain events**, and **Reactions**.


#### Commands


Commands involve actions performed by the users. Whenever a message is received by the microservice, such as _CreateSession_, a new Command is generated by the infrastructure layer.


The latter in turn sends them to the application layer, which is responsible for validating them, and eventually emits new Domain Events.
The possible Commands are:


- _UserToken_: the user sends the token to start communicating with the microservice;
- _CreateSession_: the user wants to create a new session, by providing a URL;
- _JoinSession_: the user wants to join an already existing session, by providing the session name;
- _LeaveSession_: the user wants to leave a previously joined session;
- _SendMessage_: the user wants to send a message in the chat;
- _PlayVideo_: the user wants to play the session video. It should provide the timestamp where to start playing it;
- _StopVideo_: the user wants to stop the session video. It should provide the timestamp where to stop it.


![Commands](/img/ddd/detailed_design/session/session-service-commands.png)


Command handlers are defined in the application layer through an `ISessionService` interface:


<img src={ServiceApp} alt="service" style={{ display: 'block', margin: 'auto' }} />


#### Domain events


Domain events are emitted by the application layer whenever a Command is validated and they represent a mechanism through which the domain aggregates are informed of user actions. In particular:


- Whenever a _CreateSession_ Command is accepted, `SessionService` adds a new Session aggregate to its local Session Repository;
- An Event Bus is passed as a parameter to this new Session, through which it can listen to new Domain events;
- Each command has a respective Domain event, except _UserTokenCommand_ which is used for communication purposes. This means that if a Command is validated by the `SessionService`, the respective Session aggregate is informed and can react according to that event.


<img src={Aggregates} alt="Aggregates" style={{ display: 'block', margin: 'auto' }} />


![Events](/img/ddd/detailed_design/session/session-events.png)


#### Reactions


As previously mentioned, the communication part of the application should be constrained inside the infrastructure layer. As such, the User domain model shouldn't contain the physical references of the Users. This approach leads us to decouple the Session definition inside the domain layer, with the one inside the infrastructure, which for example should add/remove User references whenever a join/disconnection is validated by the business logic.


This decoupling is achieved by the use of **Reactions**.
This mechanism allows the infrastructure layer to pass a set of functions that the business logic can call whenever a Domain event is emitted.


In particular, the following Reaction implementations should be embedded inside the User Commands:


- `ISessionReactions`: used by the aggregates to add/remove User physical references inside the infrastructure's session;
- `IChatReactions`: used to send Text or Notification Messages to a specific User o to the entire Session;
- `IVideoReactions`: to retrieve the Video State of the User, to synchronize either it or the entire Session.


![Reactions](/img/ddd/detailed_design/session/session-reactions.png)


## Authentication Microservice


The Authentication microservice is responsible for managing the authentication of the users. The application provides a REST API to register and authenticate users and to generate JWT tokens.
It also manages the token validation and refresh.


### Project structure


<img src={AuthPackages} alt="auth packages" style={{ height: 500, display: 'block', margin: 'auto' }} />


The Authentication microservice follows the Clean architecture pattern to maintain separate code responsibilities and enhance software modularity. The business logic is placed in the domain layer, inside the aggregates previously identified, while the communication is captured by the infrastructure layer.


The application layer acts as a middleware between the infrastructure and domain layer. The infrastructure layer is responsible for the communication with the database and the JWT token generation. The domain layer is responsible for the business logic. The presentation layer is responsible for the REST API.


![Auth-Classes](/img/ddd/detailed_design/auth/auth-class.svg)


### Design


The software needs to manage the authentication of the users. The possible actions are:


- _Register_: the user wants to register to the application;
- _Login_: the user wants to log in to the application;
- _Logout_: the user wants to log out of the system.


Some additional actions are:


- _ValidateToken_: to validate the token;
- _RefreshToken_: to refresh the token;
- _GetData_: to get the userâ€™s data from the token.


## Profile Microservice


The Profile microservice is responsible for managing the profile of the users. The application provides a REST API to get and update the profile of the users.


The Profile service is also based on the Clean architecture pattern and follows the same structure as the Authentication service.


![Profile-Classes](/img/ddd/detailed_design/profile/profile-class.svg)


### Design


The software needs to manage the profile of the users. The possible actions are:


- _GetProfile_: the user wants to get the profile;
- _UpdateProfile_: the user wants to update the profile;


Other actions are:


- _CreateProfile_: to create the profile;
- _AddVideo_: to add a watched video to the profile.
