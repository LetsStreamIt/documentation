---
sidebar_position: 6
---
import Packages from '/img/ddd/detailed_design/session/packages.png';
import ServiceApp from '/img/ddd/detailed_design/session/session-service-application.png';

# Detailed Design


## Session Microservice

The Session microservice is responsible for managing Youtube streaming sessions. The application synchronizes the video of all the users connected to a session, in response to play/stop/timeline moves actions.

It also maintains up to date a Session chat, through users can communicate between each other during the streaming.

### Project structure

<img src={Packages} alt="packages" style={{ height: 500, display: 'block', margin: 'auto' }} />

The Session microservice follows the Clean architecture pattern to maintain separated the code responsibilities and enhance software modularity. The business logic is placed in the domain layer, inside the aggregates previously identified, while the communication is captured by the infrastructure layer.

The application layer contains stateless objects and acts as a middleware between the infrastructure and domain layer.


### Design

The software moves around the concepts of **Commands**, **Domain events** and **Reactions**.

#### Commands

Commands involve actions performed by the users. Whenever a message is received by the microservice, such as *CreateSession*, a new Command is generated by the infrastructure layer.

The latter in turn sends them to the application layer, that is responsible to validate them, and eventually emits new Domain Events.
The possible Commands are:
- *UserToken*: the user sends the token to start communicate with the microservice;
- *CreateSession*: the user wants to create a new session, by providing a URL;
- *JoinSession*: the user wants to join an already existing session, by providing the session name;
- *LeaveSession*: the user wants to leave a previously joined session;
- *SendMessage*: the user wants to send a message in the chat;
- *PlayVideo*: the user wants to play the session video. It should provide the timestamp where to start playing it;
- *StopVideo*: the user wants to stop the session video. It should provide the timestamp where to stop it.

![Commands](/img/ddd/detailed_design/session/session-service-commands.png)

Command handlers are defined in the application layer through a `ISessionService` interface:

<img src={ServiceApp} alt="service" style={{ display: 'block', margin: 'auto' }} />

#### Domain events

Domain events are emitted by the application layer whenever a Command is validated and they represent a mechanism through which the domain aggregates are informed of user actions. In particular:

- Whenever a *CreateSession* Command is accepted, `SessionService` adds a new Session aggregate to its local Session Repository;
- An Event Bus is passed as parameter to this new Session, through which it can listen to new Domain events;
- Each command has a respective Domain event, except *UserTokenCommand* that is used for communication purposes. This means that if a Command is validated by the `SessionService`, the respective Session aggregate is informed and can react according to that event.

![Events](/img/ddd/detailed_design/session/session-events.png)


#### Reactions

As previously mentioned, the communication part of the application should be constrained inside the infrastructure layer. As such, the User domain model shouldn't contain the physical references of the Users. This approach leads us to decouple the Session definition inside the domain layer, with the one inside the infrastructure, that for example should add/remove User references whenever a join/disconnection is validated by the business logic.

This decoupling is achieved by the use of **Reactions**.
This mechanism allows the infrastructure layer to pass a set of functions that the business logic can call whenever a Domain event is emitted.

In particular, the following Reactions implementations should be embedded inside the User Commands:
- `ISessionReactions`: used by the aggregates to add/remove User physical references inside the infrastructure's session;
- `IChatReactions`: used to send Text or Notification Messages to a specific User o to the entire Session;
- `IVideoReactions`: to retreive the Video State of the User, to synchronize either it or the entire Session.

![Reactions](/img/ddd/detailed_design/session/session-reactions.png)
